name: Deploy Exit Node

on:
  workflow_dispatch:
    inputs:
      region:
        description: 'Fly.io Gateway Region'
        required: true
        default: 'fra'
        type: choice
        options:
          # Europe
          - fra  # üá©üá™ Frankfurt, Germany (Recommended - Highest capacity)
          - ams  # üá≥üá± Amsterdam, Netherlands
          - lhr  # üá¨üáß London, United Kingdom
          - cdg  # üá´üá∑ Paris, France
          # North America - US East
          - iad  # üá∫üá∏ Ashburn, Virginia (US)
          - ord  # üá∫üá∏ Chicago, Illinois (US)
          # North America - US West
          - sjc  # üá∫üá∏ San Jose, California (US)
          - sea  # üá∫üá∏ Seattle, Washington (US)
          # North America - US Central
          - dfw  # üá∫üá∏ Dallas, Texas (US)
          # North America - Canada/Mexico
          - yyz  # üá®üá¶ Toronto, Canada
          - qro  # üá≤üáΩ Quer√©taro, Mexico
          # Asia Pacific
          - nrt  # üáØüáµ Tokyo, Japan
          - sin  # üá∏üá¨ Singapore, Singapore
          - hkg  # üá≠üá∞ Hong Kong, Hong Kong
          - syd  # üá¶üá∫ Sydney, Australia
          - bom  # üáÆüá≥ Mumbai, India
          # South America
          - scl  # üá®üá± Santiago, Chile

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Fly.io CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Verify flyctl installation
        run: |
          echo "PATH: $PATH"
          which flyctl || echo "flyctl not found"
          ls -la /opt/hostedtoolcache/flyctl/ || echo "flyctl directory not found"
          flyctl version || echo "flyctl version failed"

      - name: Destroy existing app (if exists)
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          APP_NAME: ${{ secrets.APP_NAME }}
        run: |
          if flyctl status --app "$APP_NAME" &> /dev/null; then
            echo "üóëÔ∏è Destroying existing app: $APP_NAME"
            flyctl apps destroy "$APP_NAME" --yes
            echo "‚úÖ Existing app destroyed successfully"
            # Wait a moment for cleanup
            sleep 5
          else
            echo "‚ÑπÔ∏è No existing app to destroy"
          fi

      - name: Deploy Exit Node
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
          HEADSCALE_URL: ${{ secrets.HEADSCALE_URL }}
          TS_AUTHKEY: ${{ secrets.TS_AUTHKEY }}
          APP_NAME: ${{ secrets.APP_NAME }}
          REGION: ${{ github.event.inputs.region }}
        run: |
          # Update fly.toml with selected region and app name
          sed -i "s/app = .*/app = \"$APP_NAME\"/" fly.toml
          sed -i "s/primary_region = .*/primary_region = \"$REGION\"/" fly.toml
          
          # Create app (will be new since we destroyed the old one)
          echo "üöÄ Creating new app: $APP_NAME in gateway region: $REGION"
          flyctl apps create "$APP_NAME" --org personal
          
          # Set secrets (including optional state file)
          flyctl secrets set \
            TS_AUTHKEY="$TS_AUTHKEY" \
            TS_STATE_DIR="/var/lib/tailscale" \
            TS_USERSPACE="true" \
            TS_ACCEPT_DNS="false" \
            TS_HOSTNAME="fly-exit-node" \
            TS_ROUTES="0.0.0.0/0,::/0" \
            TS_EXTRA_ARGS="--login-server=$HEADSCALE_URL --advertise-tags=tag:fly --accept-routes --netfilter-mode=off" \
            TS_AUTH_ONCE="true" \
            TS_EPHEMERAL="false" \
            --app "$APP_NAME"
          
          # Set state file if it exists as a secret (base64 encoded)
          if [ ! -z "${{ secrets.TS_STATE_FILE_BASE64 }}" ]; then
            echo "üìÑ Setting Tailscale state file from secret"
            flyctl secrets set \
              TS_STATE_FILE_BASE64="${{ secrets.TS_STATE_FILE_BASE64 }}" \
              --app "$APP_NAME"
          fi
          
          # Deploy with explicit single machine settings for free tier
          echo "üì¶ Deploying single machine to gateway region: $REGION (free tier optimized)"
          flyctl deploy \
            --app "$APP_NAME" \
            --ha=false \
            --strategy=immediate \
            --vm-size=shared-cpu-1x \
            --vm-memory=256mb
          
          # Verify only one machine exists and clean up if needed
          echo "üßπ Verifying single machine deployment..."
          MACHINE_COUNT=$(flyctl machines list --app "$APP_NAME" --json | jq length)
          
          if [ "$MACHINE_COUNT" -gt 1 ]; then
            echo "‚ö†Ô∏è Found $MACHINE_COUNT machines, this shouldn't happen with --ha=false"
            echo "üîß Cleaning up extra machines to stay on free tier..."
          
            # Get all machines and keep only the newest one
            MACHINES=$(flyctl machines list --app "$APP_NAME" --json | jq -r 'sort_by(.created_at) | reverse | .[].id')
            NEWEST_MACHINE=$(echo "$MACHINES" | head -n 1)
          
            echo "$MACHINES" | tail -n +2 | while read machine_id; do
              echo "Removing extra machine: $machine_id"
              flyctl machines remove "$machine_id" --app "$APP_NAME" --force
            done
          
            echo "‚úÖ Kept only newest machine: $NEWEST_MACHINE"
          else
            echo "‚úÖ Perfect! Only $MACHINE_COUNT machine found as expected"
          fi
          
          # Final verification
          echo ""
          echo "üìä Final deployment status:"
          flyctl status --app "$APP_NAME"
          
          echo ""
          echo "‚úÖ Single-machine exit node deployed successfully in gateway region $REGION"
          echo "üí∞ Optimized for Fly.io free tier (1 machine, shared-cpu-1x, 256MB)"
          echo "üåê Node hostname: fly-exit-node"
          echo "üîó Gateway region benefits: WireGuard access, SSH connectivity, private networking"
          echo "üí° To extract state file: flyctl ssh console --app $APP_NAME -C 'base64 -w 0 /var/lib/tailscale/tailscaled.state'"